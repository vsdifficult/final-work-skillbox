# Анализ архитектурных опций и обоснование выбора

На старте:
- Требования активно уточняются.
- Команда ограничена по ресурсам.
- Нужно быстро вывести MVP для проверки гипотез.
- Нагрузки ещё не экстремальны.
- В будущем ожидается рост до сотен тысяч пользователей.

Поэтому важно выбрать архитектуру, которая позволит быстро начать, но не заблокирует масштабирование в будущем.

---

# Критерии оценки архитектурных опций

Каждая архитектурная опция анализируется по следующим параметрам:

- **Time-to-market** (скорость вывода MVP)
- **Стоимость разработки**
- **Стоимость эксплуатации (OPEX)**
- **Сложность внедрения**
- **Возможность масштабирования**
- **Риски долгосрочного роста**
- **Надёжность и отказоустойчивость**
- **Барьеры для команды**
- **Наблюдаемость и поддерживаемость**
- **Гибкость изменений в будущем**

---

# Опция 1. Монолит на стадии MVP

Использование единой кодовой базы, общего приложения и общей СУБД.

## Плюсы
- **Очень быстрый запуск MVP.**
- Простая отладка, простые pipeline-и, минимум DevOps.
- Легко вносить изменения: одна точка сборки.
- Минимальная стоимость инфраструктуры.
- Подходит для маленькой команды.

## Минусы
- Трудно масштабировать по отдельным направлениям.
- Слабая изоляция доменов.
- Риски ухудшения модульности → превращение в "монолит-ком".
- Напряжённость при росте количества разработчиков.
- Падение одного модуля может сбивать всё приложение.

## Когда подходит
- Ранние стадии проекта.
- Проверка продуктовых гипотез.
- Неясные или постоянно меняющиеся требования.

## Риски
- Будущая цена разделения значительно растёт, если монолит «зарастёт грязью».
- Усложнение релизов, когда размер кода становится критичным.

---

# Опция 2. Модульный монолит

Модульный монолит = единый деплой, но чёткое разделение доменов:  
отдельные слои, контексты, пакеты, API между модулями.

## Плюсы
- Быстрый старт (как монолит), но:
- **Чёткая структура доменов (DDD).**
- Можно внедрить отдельные модели данных по bounded contexts.
- Проще наблюдаемость и тестирование.
- Проще миграция в микросервисы: минимизирует будущие затраты.
- Сохраняет единую точку деплоя и простоту инфраструктуры.

## Минусы
- Всё равно единый runtime.
- Ошибка в одном модуле может ударить по всей системе.
- Требует дисциплины команды и архитектурного контроля.

## Когда подходит
- Стадия **MVP и пост-MVP**, когда структура доменов уже формируется.
- Когда есть планы -> микросервисы, но не сразу.
- Для команды 3–10 разработчиков.

## Риски
- При отсутствии архитектурного контроля модули начнут переплетаться.

---

# Опция 3. Микросервисы

Высокая фрагментация архитектуры: каждый домен — отдельный сервис, собственная БД, раздельные деплои.

## Плюсы
- **Отдельное масштабирование сервисов.**
- Идеальная изоляция доменов.
- Независимые релизы.
- Возможность выбирать технологии per-service.
- Хорошо подходит при миллионах пользователей.

## Минусы
- Высокая стоимость входа:
  - CI/CD на каждый сервис  
  - observability  
  - API Gateway  
  - service mesh  
  - брокер сообщений  
  - миграции БД  
- Требуются квалифицированные кадры.
- Сложнее тестирование и отладка.
- Значительный рост OPEX.

## Когда подходит
- Когда есть устойчивая продуктовая модель.
- Когда сервисы работают под высокой нагрузкой.
- Когда команда ≥ 20 человек.

## Риски
- Система может стать слишком сложной и дорогой без необходимости.
- Ошибки в коммуникации сервисов приводят к лавинообразным сбоям.

---

# Опция 4. Микросервисы после product–market fit

Промежуточный вариант: стартуем проще → масштабируем постепенно.

## Плюсы
- Компромисс между скоростью и стабильностью.
- Снижение ранней стоимости.
- Контролируемая миграция доменов.
- Естественный рост архитектуры вместе с проектом.

## Минусы
- Нужно заранее проектировать модули правильно.
- Требуется внимательный контроль границ доменов.

## Когда подходит
- Это лучший вариант для растущего стартапа.
- Подходит, если нагрузка увеличивается постепенно.

---

# Выбранное решение

## Решение: **Модульный монолит с возможностью дальнейшего выделения микросервисов**

### Почему именно так

1. **Проект на раннем этапе → важна скорость MVP.**  
   Монолит позволяет быстро проверять гипотезы, выпускать фичи и исправлять дефекты.

2. **Но проект будет расти → нужна структурированность.**  
   Модульный монолит позволяет заранее заложить правильные границы доменов, чтобы не превратить систему в неуправляемый монолит-ком.

3. **Нагрузки пока умеренные, но трекинг может стать high-load через 1–2 года.**  
   Поэтому должна быть возможность перенести *Tracking*, *Integrations*, *Analytics* в отдельные сервисы.

4. **Команда может развивать архитектуру постепенно.**  
   Сейчас нет смысла тратить месяцы на построение микросервисной инфраструктуры.

5. **Минимизация затрат на инфраструктуру.**  
   Микросервисы требуют Kafka-кластера, API Gateway, Mesh, трейсинга, отдельных баз, CI/CD.  
   Это высокий OPEX, который не нужен на этапе MVP.

6. **Наблюдаемость и безопасность легче внедрить в одном процессе.**  
   До стадии микросервисов можно отстроить логику мониторинга, логирования, RBAC, rate-limits.

7. **Гладкий переход в микросервисы (Strangler Pattern).**  
   Каждый модуль может быть вынесен в отдельный сервис без переписывания логики:
   - Training Service  
   - Tracking Service  
   - Social Service  
   - Integrations Service  

---

# Итоговое обоснование

Выбор модульного монолита — **компромиссное, стратегически правильное решение**, потому что:

- Старт быстрый.  
- Стоимость низкая.  
- Архитектура контролируемая.  
- Проблемы монолита устранены структурой модулей.  
- Система готова к росту.  
- Переход к микросервисам возможен без боли и переписываний.  

Система растёт вместе с продуктом:  
**MVP → post-MVP → high-load → микросервисы.**


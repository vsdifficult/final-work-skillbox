# Architecture Decision Records (ADR)

---

## ADR-001 — Выбор архитектурного стиля: модульный монолит

### Контекст
Проект только запускается, доменная модель ещё формируется, команда небольшая, сроки MVP ограничены.

### Проблема
Необходимо обеспечить быстрый старт разработки без усложнений.

### Решение
Использовать **модульный монолит** с чётким разделением доменных контекстов.

### Альтернативы
1. Микросервисы с нуля  
2. Self-contained Systems  
3. Hexagonal + микросервисы сразу

### Почему альтернативы отклонены
- Микросервисы с нуля → дорого, сложно, громоздко, увеличивает time-to-market.  
- SCS → избыточно для MVP.  
- Full microservices → требует Service Mesh, брокеров сообщений, сложного CI/CD.

### Последствия
- Уменьшается сложность разработки.
- Быстрый релиз MVP.  
- Требуется планируемая миграция в микросервисы → см. ADR-004.

---

## ADR-002 — Выбор языка разработки: C# / .NET

### Контекст
Команда владеет .NET, приложение планируется к масштабированию, нужен сильный typed-backend.

### Проблема
Выбор языка для долгосрочной поддержки и расширяемости.

### Решение
Использовать **C# (.NET 8/9)** как основной язык проекта.

### Альтернативы
1. Node.js  
2. Java  
3. Go

### Почему отклонены
- Node.js → слабее типизация, хуже под высокие нагрузки.  
- Java → сложнее старт, тяжелее стек, выше порог входа.  
- Go → мало библиотек для наших задач (BLE, ML-интеграции, аналитика).

### Последствия
- Необходимость DevOps-инструментов под .NET.  
- Упрощение масштабирования.  
- Высокая производительность на сервере.

---

## ADR-003 — Выбор основного хранилища: PostgreSQL

### Контекст
Проект содержит структурированные данные: тренировки, профили, статистика, социальные связи.

### Проблема
Выбор универсальной, надёжной реляционной БД.

### Решение
Использовать **PostgreSQL** как основную БД.

### Альтернативы
1. MySQL  
2. MongoDB  
3. DynamoDB

### Почему альтернативы отклонены
- MySQL → слабее расширяемость и JSONB.  
- MongoDB → потеря транзакционности и строгих схем.  
- DynamoDB → привязка к конкретному вендору.

### Последствия
- Требуется проектировать схемы заранее.  
- Можно расширять JSONB-полями и индексами.  
- Отличная поддержка геоданных (важно для трекинга).

---

## ADR-004 — Переход от модульного монолита к микросервисной архитектуре

### Контекст
На старте — модульный монолит. При росте нагрузки — необходимость горизонтального масштабирования.

### Проблема
Система должна поддерживать будущее разделение нагрузки + независимые релизы.

### Решение
Реализовать **поэтапную миграцию** (Strangler Pattern):  
модуль → выделенный сервис → независимый домен.

### Альтернативы
1. Полный монолит навсегда  
2. Микросервисы сразу  
3. Функциональная архитектура (serverless-first)

### Почему отклонены
- Монолит навсегда → не выдержит нагрузки трекинга и соц-фич.  
- Микросервисы сразу → удорожание MVP.  
- Serverless-first → не подходит под BLE, интеграции, real-time.

### Последствия
- Необходимы: API Gateway, брокер сообщений, отдельное логирование.  
- Возможно временное дублирование данных.  
- Потребуются дополнительные DevOps ресурсы.

---

## ADR-005 — Выбор REST как основного API-протокола

### Контекст
Требуется простой, понятный интерфейс между сервисами и клиентами.

### Проблема
Выбор основного способа взаимодействия клиентов с сервисами.

### Решение
Использовать **REST + JSON** как основной интерфейс.

### Альтернативы
1. gRPC  
2. GraphQL  
3. WebSockets-only

### Почему отклонены
- gRPC → сложнее внедрение на мобилках, требует gateway.  
- GraphQL → избыточен для MVP, сложнее кеширование.  
- WebSockets → подходит только для real-time, не для CRUD.

### Последствия
- Больше сетевого трафика.  
- Зато высокая совместимость и простота интеграции.

---

## ADR-006 — Аутентификация: OAuth 2.0 + JWT

### Контекст
Необходима единая модель авторизации для мобильных приложений и сервисов.

### Проблема
Выбор механизма аутентификации с поддержкой масштабируемости.

### Решение
Использовать **OAuth 2.0 + JWT** (access-token + refresh-token).

### Альтернативы
1. Basic Auth  
2. Session cookies  
3. mTLS

### Почему отклонены
- Basic Auth → устарело, небезопасно.  
- Cookies → сложно на мобильных клиентах.  
- mTLS → слишком тяжело для массовых B2C-приложений.

### Последствия
- Требуется система ротации токенов.  
- Нужна revocation-лист/blacklist.  
- Необходима дополнительная защита от replay attacks.

---

## ADR-007 — Интеграции с устройствами: Kafka + Webhooks

### Контекст
Система должна получать данные от часов, датчиков, телефонов.

### Проблема
Как обрабатывать асинхронные события и данные от внешних платформ.

### Решение
Использовать:
- **Kafka** для внутренних событий,
- **Webhooks** для внешних интеграций (Apple Health, Google Fit и др.).

### Альтернативы
1. RabbitMQ  
2. REST pooling  
3. Cron-сборщик данных

### Почему отклонены
- RabbitMQ → хуже под high-throughput трекинг.  
- REST pooling → высокая нагрузка, отсутствие realtime.  
- Cron-сборщик → слишком медленно и ненадёжно.

### Последствия
- Усложняется мониторинг и DevOps.  
- Требуется observability (трассировка, DLQ).  
- Повышается надёжность и отказоустойчивость интеграций.

---

## ADR-008 — Использование API Gateway

### Контекст
Система планирует десятки сервисов и внешний мобильный трафик.

### Проблема
Как централизовать безопасность и маршрутизацию.

### Решение
Ввести **API Gateway** как единый входной слой.

### Альтернативы
1. Доступ напрямую к сервисам  
2. Nginx reverse proxy  
3. Mesh-only

### Почему отклонены
- Прямые вызовы → отсутствуют security-контролли.  
- Nginx → нет полноценного rate limiting и auth-flows.  
- Mesh → не решает внешний трафик.

### Последствия
- Централизованная аутентификация/лимитирование.  
- Удобное versioning API.  
- Больше точек конфигурации, требуется DevOps.

---

## ADR-009 — Введение Observability стека: Prometheus + Grafana + Loki + OpenTelemetry

### Контекст
Система высоконагруженная, распределённая, с большим количеством событий.

### Проблема
Как контролировать состояние сервисов и быстро устранять инциденты.

### Решение
Использовать:
- Prometheus для метрик  
- Grafana для визуализации  
- Loki для логов  
- OpenTelemetry для трассировки

### Альтернативы
1. ELK-only  
2. NewRelic / Datadog (дорого)  
3. Отсутствие единой системы мониторинга

### Почему отклонены
- ELK → слишком дорого и тяжело под большие нагрузки.  
- NewRelic → высокая стоимость.  
- Нет наблюдаемости → невозможно поддерживать масштаб.

### Последствия
- Требуется поддержка observability-инфраструктуры.  
- Улучшается SLA/SLO, скорость реакции на инциденты.  

---

## ADR-010 — Использование Kafka как основного Event Bus

### Контекст
Система содержит реальное время, трекинг, высокочастотные события.

### Проблема
Как обрабатывать большие объёмы данных и обеспечивать устойчивость.

### Решение
Использовать **Kafka** как основную шину событий.

### Альтернативы
- RabbitMQ — лучше для командных очередей, хуже под стриминг.  
- Redis Streams — ограничена под high-load durability.

### Последствия
- Требуется настройка кластера Kafka.  
- Отличная производительность и надёжность.  
- Возможность real-time analytics.

